-- Supabase Schema Definition for DoClimb App

-- -----------------------------------------------------------------------------
-- DROP existing tables, functions, and policies for a clean rebuild
-- -----------------------------------------------------------------------------

DROP TABLE IF EXISTS public.community_posts CASCADE;
DROP TABLE IF EXISTS public.records CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;

-- Drop handle_new_user function (if it exists)
DROP FUNCTION IF EXISTS public.handle_new_user() CASCADE;


-- -----------------------------------------------------------------------------
-- Create the profiles table
-- -----------------------------------------------------------------------------
CREATE TABLE public.profiles (
  id uuid NOT NULL REFERENCES auth.users ON DELETE CASCADE,
  name TEXT NOT NULL,           -- '이름' 역할, 필수
  display_nickname TEXT UNIQUE NOT NULL, -- '닉네임' 역할, 고유하고 필수
  email TEXT UNIQUE NOT NULL,             -- 사용자 이메일, 고유하고 필수 (로그인 시 필요)
  climbing_level TEXT,          -- 선택 정보
  preferred_gym TEXT,           -- 선택 정보
  climbing_style TEXT[] DEFAULT '{}'::TEXT[], -- 선택 정보, 배열
  avatar_url TEXT,
  website TEXT,
  role TEXT DEFAULT 'USER' NOT NULL, -- 역할, 기본값 USER
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  created_at TIMESTAMPTZ DEFAULT NOW(), -- 생성 시간
  PRIMARY KEY (id)
);

-- -----------------------------------------------------------------------------
-- Set up Row Level Security (RLS) for profiles table
-- -----------------------------------------------------------------------------
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Public profiles are viewable by everyone."
ON public.profiles FOR SELECT
USING (true);

CREATE POLICY "Users can insert their own profile."
ON public.profiles FOR INSERT
WITH CHECK (auth.uid() = id);

CREATE POLICY "Users can update own profile."
ON public.profiles FOR UPDATE
USING (auth.uid() = id);

CREATE POLICY "Users can delete their own profile."
ON public.profiles FOR DELETE
USING (auth.uid() = id);

-- -----------------------------------------------------------------------------
-- Function and Trigger to automatically create a profile for a new user
-- -----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.profiles (id, email, name, display_nickname, climbing_level, preferred_gym, climbing_style)
  VALUES (
    new.id,
    new.email,
    COALESCE(new.raw_user_meta_data->>'name', 'New User'),
    COALESCE(new.raw_user_meta_data->>'display_nickname', 'missing_display_nickname_' || substr(new.id::text, 1, 8)),
    new.raw_user_meta_data->>'climbing_level',
    new.raw_user_meta_data->>'preferred_gym',
    (SELECT CASE
      WHEN new.raw_user_meta_data->'climbing_style' IS NOT NULL AND jsonb_typeof((new.raw_user_meta_data->'climbing_style')::jsonb) = 'array'
      THEN ARRAY(SELECT jsonb_array_elements_text((new.raw_user_meta_data->'climbing_style')::jsonb))
      ELSE '{}'::TEXT[]
    END)
  )
  ON CONFLICT (id) DO UPDATE SET
    name = EXCLUDED.name,
    display_nickname = EXCLUDED.display_nickname,
    email = EXCLUDED.email,
    climbing_level = EXCLUDED.climbing_level,
    preferred_gym = EXCLUDED.preferred_gym,
    climbing_style = EXCLUDED.climbing_style,
    updated_at = NOW();
  RETURN new;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- -----------------------------------------------------------------------------
-- Create the records table
-- -----------------------------------------------------------------------------
CREATE TABLE public.records (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  date DATE NOT NULL,
  location TEXT,
  climb_type TEXT,
  difficulty TEXT,
  success BOOLEAN DEFAULT FALSE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL
);

-- -----------------------------------------------------------------------------
-- Set up Row Level Security (RLS) for records table
-- -----------------------------------------------------------------------------
ALTER TABLE public.records ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Users can view their own records."
ON public.records FOR SELECT
USING (auth.uid() = user_id);

CREATE POLICY "Users can insert their own records."
ON public.records FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own records."
ON public.records FOR UPDATE
USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own records."
ON public.records FOR DELETE
USING (auth.uid() = user_id);

-- -----------------------------------------------------------------------------
-- Community Posts table
-- -----------------------------------------------------------------------------
CREATE TABLE public.community_posts (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  caption TEXT,
  image_url TEXT,
  user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL
);

-- -----------------------------------------------------------------------------
-- Set up Row Level Security (RLS) for community_posts table
-- -----------------------------------------------------------------------------
ALTER TABLE public.community_posts ENABLE ROW LEVEL SECURITY;

CREATE POLICY "All users can view all posts."
ON public.community_posts FOR SELECT
USING (true);

CREATE POLICY "Users can insert their own posts."
ON public.community_posts FOR INSERT
WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update their own posts."
ON public.community_posts FOR UPDATE
USING (auth.uid() = user_id);

CREATE POLICY "Users can delete their own posts."
ON public.community_posts FOR DELETE
USING (auth.uid() = user_id);

-- -----------------------------------------------------------------------------
-- Supabase Storage for Avatars
-- -----------------------------------------------------------------------------

-- Create a public bucket for avatars
INSERT INTO storage.buckets (id, name, public)
VALUES ('avatars', 'avatars', true)
ON CONFLICT (id) DO NOTHING;

-- Policies for avatars bucket
-- Allow public read access to everyone
CREATE POLICY "Allow public read access on avatars" ON storage.objects FOR SELECT USING (bucket_id = 'avatars');

-- Allow authenticated users to upload their own avatar
CREATE POLICY "Allow authenticated users to upload avatars" ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'avatars' AND auth.role() = 'authenticated' AND (storage.foldername(name))[1] = auth.uid()::text);

-- Allow users to update their own avatar
CREATE POLICY "Allow users to update their own avatars" ON storage.objects FOR UPDATE USING (bucket_id = 'avatars' AND auth.uid() = owner);

-- Allow users to delete their own avatar
CREATE POLICY "Allow users to delete their own avatars" ON storage.objects FOR DELETE USING (bucket_id = 'avatars' AND auth.uid() = owner);

-- -----------------------------------------------------------------------------
-- Supabase Storage for Post Images
-- -----------------------------------------------------------------------------

-- Create a bucket for post images
INSERT INTO storage.buckets (id, name, public)
VALUES ('post_images', 'post_images', false)
ON CONFLICT (id) DO NOTHING;

-- Policies for post_images bucket
-- Allow all users to view images
CREATE POLICY "Allow all users to view images." ON storage.objects FOR SELECT USING (bucket_id = 'post_images');

-- Allow authenticated users to upload images
CREATE POLICY "Allow authenticated users to upload images." ON storage.objects FOR INSERT WITH CHECK (bucket_id = 'post_images' AND auth.role() = 'authenticated');

-- Allow users to update their own images
CREATE POLICY "Allow users to update their own images." ON storage.objects FOR UPDATE USING (bucket_id = 'post_images' AND auth.uid() = owner);

-- Allow users to delete their own images
CREATE POLICY "Allow users to delete their own images." ON storage.objects FOR DELETE USING (bucket_id = 'post_images' AND auth.uid() = owner);
